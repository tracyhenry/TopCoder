#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long
#define pi 3.1415926535897932384626433 
#define sqr(a) ((a)*(a))
using namespace std;
	
class SegmentDrawing {
public:
	int maxScore(vector <int> x, vector <int> y, vector <int> redScore, vector <int> blueScore);
};


struct node
{
    int x, next, opp, left;
};

struct point
{
	int x, y;
	
	point() {}
	point(int _x, int _y) : x(_x), y(_y) {}
};

const int maxn = 300000;
const int maxm = 400000;

node z[maxm];
int h[maxn], u[maxn];
int d[maxn], pre[maxn], q[maxn];
int now[maxn], w[maxn], flag;
int f, r, s, t, tot, v, ans;

void cleargraph(int ss, int tt)
{
    memset(h, 0, sizeof(h));
	s = ss, t = tt;
    tot = 0;
}

void ins(int x, int y, int c)
{
    int t1 = ++ tot, t2 = ++ tot;
    z[t1].x = y; z[t1].left = c; z[t1].next = h[x]; h[x] = t1;
    z[t2].x = x; z[t2].left = 0; z[t2].next = h[y]; h[y] = t2;
    z[t1].opp = t2;
    z[t2].opp = t1;
}

void refresh(int x)
{
    w[d[x]] --;
    if (! w[d[x]])
    {
        flag = 1; return ;
    }
    d[x] = t + 1; now[x] = h[x];
    for (int i = h[x]; i; i = z[i].next)
        if (z[i].left && d[z[i].x] + 1 < d[x])
            d[x] = d[z[i].x] + 1;
    w[d[x]] ++;
}

void augment()
{
    int delta = 1 << 30;
    for (int i = t; i != s; )
    {
        int j = pre[i];
        delta = min(delta, z[j].left);
        i = z[z[j].opp].x;
    }
    ans += delta;
    for (int i = t; i != s; )
    {
        int j = pre[i];
        z[j].left -= delta;
        z[z[j].opp].left += delta;
        i = z[z[j].opp].x;
    }
}

int maxflow()
{
    ans = 0;
    //BFS
    memset(u, 0, sizeof(u)); u[t] = 1;
    for (int i = s; i <= t; i ++) d[i] = t + 1;
    d[t] = 0;
    q[1] = t; f = 0; r = 1; 
    while (f < r)
    {
        int x = q[++ f];
        for (int i = h[x]; i; i = z[i].next)
            if (! u[z[i].x])
            {
                u[z[i].x] = 1;
                d[z[i].x] = d[x] + 1;
                q[++ r] = z[i].x;
            }
    }
    memset(w, 0, sizeof(w));
    for (int i = s; i <= t; i ++)
    {
        now[i] = h[i];
        w[d[i]] ++;
    }
    v = s; flag = 0;
    while (d[s] <= t)
        if (v == t)
        {
            augment(); v = s;
        }
        else
        {
            int j = now[v];
            while (j)
            {
                if (z[j].left && d[v] == d[z[j].x] + 1)
                    break;
                j = z[j].next;
            }
            if (j)
            {
                pre[z[j].x] = j;
                now[v] = j;
                v = z[j].x;
            }
            else
            {
                refresh(v);
                if (flag) break;
                if (v != s) v = z[z[pre[v]].opp].x;
            }
        } 
    return ans;
}


int cmp(int x)
{
    if (x == 0) return 0;
    if (x > 0) return 1;
    return -1;
}

int det(point a, point b, point c)
{
    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}

int cross(point a, point b, point c, point d)
{
    int l1, r1, l2, r2;
    //x
    l1 = min(a.x, b.x); r1 = max(a.x, b.x);
    l2 = min(c.x, d.x); r2 = max(c.x, d.x);
    if (r1 < l2 || r2 < l1) return 0;
    //y
    l1 = min(c.y, d.y); r1 = max(c.y, d.y);
    l2 = min(c.y, d.y); r2 = max(c.y, d.x);
    if (r1 < l2 || r2 < l1) return 0;    
    if (cmp(det(a, c, b)) * cmp(det(a, b, d)) < 0) return 0;
    if (cmp(det(c, a, d)) * cmp(det(c, d, b)) < 0) return 0;
    return 1;
}


int SegmentDrawing::maxScore(vector <int> x, vector <int> y, vector <int> redScore, vector <int> blueScore) 
{
	int n = x.size();
	vector<point> P; P.clear();
	for (int i = 0; i < n; i ++)
		P.push_back(point(x[i], y[i]));
	cleargraph(0, n * n + 1);
	
	//build graph
	for (int i = 0; i < n; i ++)
		for (int j = i + 1; j < n; j ++)
			ins(s, i * n + j + 1, redScore[i * n + j]);
	for (int i = 0; i < n; i ++)
		for (int j = 0; j < i; j ++)
			ins(i * n + j + 1, t, blueScore[i * n + j]);
	
	for (int i = 0; i < n; i ++)
		for (int j = i + 1; j < n; j ++)
			for (int p = 0; p < n; p ++)
				for (int q = 0; q < p; q ++)
				{
					int f1 = i * n + j + 1;
					int f2 = p * n + q + 1;
					
					if (cross(P[i], P[j], P[p], P[q]))
						ins(f1, f2, 100000000);
				}
	
	
	int sum = 0;
	for (int i = 0; i < redScore.size(); i ++)
		sum += redScore[i] + blueScore[i];
	sum /= 2;
	return sum - maxflow();
}
	


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, vector <int> p3, bool hasAnswer, int p4) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}";
	cout << "]" << endl;
	SegmentDrawing *obj;
	int answer;
	obj = new SegmentDrawing();
	clock_t startTime = clock();
	answer = obj->maxScore(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	int p4;
	
	{
	// ----- test 0 -----
	int t0[] = {0,1,0,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,0,-1,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,1,2,3,1,0,6,4,2,6,0,5,3,4,5,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {0,2,3,7,2,0,4,6,3,4,0,5,7,6,5,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 27;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,101,101,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {0,100,100,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 101;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {-3,-1,-1,1,1,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,-2,2,-2,2,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,2,1,2,1,2,2,0,2,1,2,1,1,2,0,2,1,2,2,1,2,0,2,1,1,2,1,2,0,2,2,1,2,1,2,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 25;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {-100,100,0,-10,10,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,0,100,10,10,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,96,96,25,25,25,96,0,96,25,25,25,96,96,0,25,25,25,25,25,25,0,10,10,25,25,25,10,0,10,25,25,25,10,10,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {0,30,30,20,20,20,30,0,30,20,20,20,30,30,0,20,20,20,20,20,20,0,86,86,20,20,20,86,0,86,20,20,20,86,86,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 546;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {1,2,3,4,5,6,7,8,9,10};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,4,9,16,25,36,49,64,81,100};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,15,2,3,4,5,6,7,8,9,15,0,15,2,3,4,5,6,7,8,2,15,0,15,2,3,4,5,6,7,3,2,15,0,15,2,3,4,5,6,4,3,2,15,0,15,2,3,4,5,5,4,3,2,15,0,15,2,3,4,6,5,4,3,2,15,0,15,2,3,7,6,5,4,3,2,15,0,15,2,8,7,6,5,4,3,2,15,0,15,9,8,7,6,5,4,3,2,15,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {0,0,2,3,4,5,6,7,8,9,0,0,0,2,3,4,5,6,7,8,2,0,0,0,2,3,4,5,6,7,3,2,0,0,0,2,3,4,5,6,4,3,2,0,0,100,2,3,4,5,5,4,3,2,100,0,0,2,3,4,6,5,4,3,2,0,0,0,2,3,7,6,5,4,3,2,0,0,0,2,8,7,6,5,4,3,2,0,0,0,9,8,7,6,5,4,3,2,0,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 300;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING





//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
